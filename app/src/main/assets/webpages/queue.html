<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
        pre{
        padding-top:16px;
        padding-right:0px;
        padding-bottom:16px;
        padding-left:0px;
        background-color:#111430;
        color: #ffffff;
        white-space: pre-wrap;
        } </style>

</head>
<body>
<h2>Queue Data Structures</h2>
<p>Queue is also an abstract data type or a linear data structure, in which the first element is inserted from one end called <b>REAR</b>(also called tail), and the deletion of exisiting element takes place from the other end called as <b>FRONT</b>(also called head). This makes queue as FIFO data structure, which means that element inserted first will also be removed first.</p>
<p>The process to add an element into queue is called <b>Enqueue</b> and the process of removal of an element from queue is called <b>Dequeue</b>.</p>

<hr/>
<h4>Basic features of Queue</h4>
<ol class="content">
    <li>Like Stack, Queue is also an ordered list of elements of similar data types.</li>
    <li>Queue is a FIFO( First in First Out ) structure.</li>
    <li>Once a new element is inserted into the Queue, all the elements inserted before the new element in the queue must be removed, to remove the new element.</li>
    <li><b>peek( )</b> function is oftenly used to return the value of first element without dequeuing it.</li>
</ol>
<hr/>
<h4>Applications of Queue</h4>
<p>Queue, as the name suggests is used whenever we need to have any group of objects in an order in which the first one coming in, also gets out first while the others wait for there turn, like in the following scenarios :</p>
<ol class="content">
    <li>Serving requests on a single shared resource, like a printer, CPU task scheduling etc.</li>
    <li>In real life, Call Center phone systems will use Queues, to hold people calling them in an order, until a service representative is free.</li>
    <li>Handling of interrupts in real-time systems. The interrupts are handled in the same order as they arrive, First come first served.</li>
</ol>
<hr/>
<h4>Implementation of Queue</h4>
<p>Queue can be implemented using an Array, Stack or Linked List. The easiest way of implementing a queue is by using an Array. Initially the <b>head</b>(FRONT) and the <b>tail</b>(REAR) of the queue points at the first index of the array (starting the index of array from 0). As we add elements to the queue, the tail keeps on moving ahead, always pointing to the position where the next element will be inserted, while the head remains at the first index.</p>

<p>When we remove element from Queue, we can follow two possible approaches (mentioned [A] and [B] in above diagram). In [A] approach, we remove the element at <b>head</b> position, and then one by one move all the other elements on position forward. In approach [B] we remove the element from <b>head</b> position and then move <b>head</b> to the next position.</p>
<p>In approach [A] there is an overhead of shifting the elements one position forward every time we remove the first element. In approach [B] there is no such overhead, but whener we move head one position ahead, after removal of first element, the size on Queue is reduced by one space each time.</p>
<pre>/*Below program is written in C++ language*/

#define SIZE 100
class <b>Queue</b>
{
  int a[100];
  int rear;     //same as tail
  int front;    //same as head

  public:
  Queue()
  {
    rear = front = -1;
  }
  void enqueue(int x);
  int dequeue();
  void display();
}

void Queue :: <b>enqueue</b>(int x)
{
  if( rear = SIZE-1)
  {
    cout << "Queue is full";
  }
  else
  {
    a[++rear] = x;
  }
}

int queue :: <b>dequeue</b>()
{
  return a[++front];
}

void queue :: <b>display</b>()
{
  int i;
  for( i = front; i <= rear; i++)
  {
    cout << a[i];
  }
}
</pre>
<p>To implement approach [A], you simply need to change the dequeue method, and include a for loop which will shift all the remaining elements one position.</p>
<pre>
return a[0];      //returning first element
for (i = 0; i < tail-1; i++)
{
  a[i]= a[i+1];
  tail--;
}
</pre>
<hr/>
<h4>Analysis of Queue</h4>
<ul class="content">
    <li>Enqueue : <b>O(1)</b></li>
    <li>Dequeue : <b>O(1)</b></li>
    <li>Size : <b>O(1)</b></li>
</ul>
<hr/>
</body>
</html>